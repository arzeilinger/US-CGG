---
title: "Bootstrap GAM for all groups"
output: html_document
---
```{r echo = FALSE}
require(dplyr)
require(mgcv)
library(mgcv)
library(ggplot2)
library(ISLR)
library(mgcv)
library(boot)
require(matrixStats)
library(zoo)
```



#load tower and eosense data

#Defining the data I/O directory

```{r}
## change root.path as needed
root.path<-"C:\\Users\\tfens\\R_REPOS\\Flux_processing\\Concord_R_Code\\Concord_Post_Process\\"
# root.path<-"D:\\Housen\\Flux\\Data-exploring\\02_Concord_Eden\\"

# this is tower data for the GAM model lives
GAM.path<-paste0(root.path,"14_GAM_ready_Data\\") 

#this is were the data for the eosense data for the GAM model lives
eosense.path<- paste0(root.path,"14_GAM_ready_Data\\")

#output folder
out.path<-paste0(root.path, "15_GAM_predict_data\\")
```



#reading in a specific file

```{r}
## use follows to specify the versions of the combined file
# file name of the combined_file
cdata.GAM_all_data<-paste0("2022-05-02_all_GAM_data.csv")

cdata.eo_sense <- paste("eo_sense_20210806.csv")
```


```{r}
all_daily_data <- readRDS (file = "2022-04-20_all_data_daily.rda" )

# cdata.GAM_test <- paste("2021-07-13_control_post_compost_GAM_data.csv")
 
```

#Tower data for the GAM model

```{r}
## read in full output file of gap filled data
GAM_all_data <-
  read.csv(
    paste0(GAM.path, cdata.GAM_all_data, sep = ""),
    header = T,
    na.strings = "NA",
    stringsAsFactors = F
  )


```

#Read in eosense data for the GAm model

```{r}
## read in eo_sensee_data
eosense.data <-
  read.csv(
    paste0(eosense.path, cdata.eo_sense, sep = ""),
    header = T,
    na.strings = "NA",
    stringsAsFactors = F
  )

```

#adding POSIXT format back to GAM_all_data

```{r}

GAM_all_data$TIMESTAMP <- strptime(paste(GAM_all_data$TIMESTAMP),
                                 format = "%m/%d/%Y %H:%M",
                                 tz = "UTC")

plot( GAM_all_data$TIMESTAMP, GAM_all_data$NEE)
```
#Create Time id
```{r}
GAM_all_data$time.id <- GAM_all_data$TIMESTAMP$year + 1900 +
  (GAM_all_data$TIMESTAMP$yday) / 366 +
  (GAM_all_data$TIMESTAMP$hour) / 366 / 24 +
  (GAM_all_data$TIMESTAMP$min) / 366 / 24 / 60

plot(GAM_all_data$TIMESTAMP, GAM_all_data$time.id)

```

#creating timestamp for eosense data

```{r}

eosense.data$Year <- eosense.data$Year + 2000

#combining month day year into a date column.
eosense.data$Date <-
  paste(eosense.data$Month, eosense.data$Day, eosense.data$Year, sep = "/")

#creating a timestamp based on
eosense.data$TIMESTAMP <-
  strptime(
    paste(eosense.data$Date, eosense.data$Time, sep = " "),
    format = "%m/%d/%Y %H:%M ",
    tz = "UTC"
  )

plot(eosense.data$TIMESTAMP, eosense.data$Flux)

```

```{r}
#creating time id for eosense data
eosense.data$time.id <- eosense.data$TIMESTAMP$year + 1900 +
  (eosense.data$TIMESTAMP$yday) / 366 +
  (eosense.data$TIMESTAMP$hour) / 366 / 24 +
  (eosense.data$TIMESTAMP$min) / 366 / 24 / 60

eosense.data$time.id[1:50]
plot(eosense.data$TIMESTAMP, eosense.data$time.id)

which(duplicated(eosense.data$time.id))

eosense.data %>% distinct(time.id, .keep_all = TRUE)

head(eosense.data)
```

#creating full time stamp without gaps for merging data

```{r}

# create a full timestamp, 30 mins
full.time <- data.frame(
  TIMESTAMP =
    seq.POSIXt(
      min(min(GAM_all_data$TIMESTAMP), min(eosense.data$TIMESTAMP)),
      max(max(GAM_all_data$TIMESTAMP), max(eosense.data$TIMESTAMP)),
      units = "seconds",
      by = 1800
    ),
  stringsAsFactors = F
)

full.time$TIMESTAMP <- strptime(full.time$TIMESTAMP,
                                format = "%Y-%m-%d %H:%M:%S",
                                tz = "Etc/GMT-8")

full.time$time.id <- full.time$TIMESTAMP$year + 1900 +
  (full.time$TIMESTAMP$yday) / 366 +
  (full.time$TIMESTAMP$hour) / 366 / 24 +
  (full.time$TIMESTAMP$min) / 366 / 24 / 60

print(paste("Starting timestamp:", full.time$TIMESTAMP[1]))
print(paste("Ending timestamp:", full.time$TIMESTAMP[nrow(full.time)]))

head(full.time)

which(duplicated(full.time$time.id))

```

#merging tower and eosense data

```{r}
tower_eo_sense.data <- merge.data.frame(
  full.time,
  GAM_all_data[, -which(colnames(GAM_all_data) == "TIMESTAMP")],
  by = "time.id",
  all = TRUE,
  sort = TRUE)

#all=true what ever appears in each file is show in the file data file. sort tries to sort each data frame by merging. in this case probably doesnot matter. timestamp

tower_eo_sense.data <- merge.data.frame(
  tower_eo_sense.data,
  eosense.data[, -which(colnames(eosense.data) == "TIMESTAMP")],
  by = "time.id",
  all = TRUE,
  sort = TRUE
)

# drop missing timestamps
tower_eo_sense.data <-
  tower_eo_sense.data[!is.na(tower_eo_sense.data$TIMESTAMP), ]

```

#Parse time-relavant index (for GAMs input)

```{r}

tower_eo_sense.data$Year <- tower_eo_sense.data$TIMESTAMP$year + 1900
tower_eo_sense.data$Month <- tower_eo_sense.data$TIMESTAMP$mon + 1
tower_eo_sense.data$HalfMonth <-
  tower_eo_sense.data$Month + ifelse(tower_eo_sense.data$TIMESTAMP$mday <= 15, 0, 0.5)
tower_eo_sense.data$Doy <- tower_eo_sense.data$TIMESTAMP$yday + 1

## get DOY as in a water year, starting from Nov 1st
tower_eo_sense.data$Doy_water <- tower_eo_sense.data$Doy
tower_eo_sense.data$Doy_water[tower_eo_sense.data$Year == 2019 &
                                tower_eo_sense.data$Doy <= 304] <-
  tower_eo_sense.data$Doy_water[tower_eo_sense.data$Year == 2019 &
                                  tower_eo_sense.data$Doy <= 304] + 61
tower_eo_sense.data$Doy_water[tower_eo_sense.data$Year == 2019 &
                                tower_eo_sense.data$Doy > 304] <-
  tower_eo_sense.data$Doy_water[tower_eo_sense.data$Year == 2019 &
                                  tower_eo_sense.data$Doy > 304] - 304
tower_eo_sense.data$Doy_water[tower_eo_sense.data$Year == 2020 &
                                tower_eo_sense.data$Doy <= 305] <-
  tower_eo_sense.data$Doy_water[tower_eo_sense.data$Year == 2020 &
                                  tower_eo_sense.data$Doy <= 305] + 61
tower_eo_sense.data$Doy_water[tower_eo_sense.data$Year == 2020 &
                                tower_eo_sense.data$Doy > 305] <-
  tower_eo_sense.data$Doy_water[tower_eo_sense.data$Year == 2020 &
                                  tower_eo_sense.data$Doy > 305] - 305
tower_eo_sense.data$Doy_water[tower_eo_sense.data$Year == 2021 &
                                tower_eo_sense.data$Doy <= 304] <-
  tower_eo_sense.data$Doy_water[tower_eo_sense.data$Year == 2021 &
                                  tower_eo_sense.data$Doy <= 304] + 61
tower_eo_sense.data$Doy_water[tower_eo_sense.data$Year == 2021 &
                                tower_eo_sense.data$Doy > 304] <-
  tower_eo_sense.data$Doy_water[tower_eo_sense.data$Year == 2021 &
                                  tower_eo_sense.data$Doy > 304] - 304

# convert doy into sin & cos 
tower_eo_sense.data$sin_Doy_water <-
  sin(tower_eo_sense.data$Doy_water / 366 * 2 * pi)

tower_eo_sense.data$cos_Doy_water <-
  cos(tower_eo_sense.data$Doy_water / 366 * 2 * pi)

#tower_eo_sense.data
```

#double check duplicated timestamps

```{r}
#seeing which rows are duplicated
which(duplicated(tower_eo_sense.data$TIMESTAMP))[1:10]

#removing duplicated rows
tower_eo_sense.data <-
  tower_eo_sense.data[!duplicated(tower_eo_sense.data$TIMESTAMP),]

#checking that this worked
which(duplicated(tower_eo_sense.data$TIMESTAMP))[1:10]


```

## Filter NEE outlier using a non-overlapped moving window
For each window, the code filters out points that are outsides of the 
window_mean +/- filter_criteria * window_sd. Currently, the process iterates
twice, using two different sizes of windows and thresholds.

```{r}
# define window size, days * points per days, scalar or vector
filter_window <- c(14 * 48, 7 * 48)
# define criteria for filtering (times +/- sd), scalar or vector
filter_criteria <- c(4, 3)
n_window <- floor(nrow(tower_eo_sense.data) / filter_window)

for(w in 1:length(n_window)) {
  for (ww in 1:n_window[w]) {
    window_mean <-
      mean(tower_eo_sense.data$NEE[c(((ww - 1) * filter_window[w] + 1):
                                       (ww * filter_window[w]))], na.rm = T)
    window_sd <-
      sd(tower_eo_sense.data$NEE[c(((ww - 1) * filter_window[w] + 1):
                                     (ww * filter_window[w]))], na.rm = T)
    
    if (is.finite(window_mean) & is.finite(window_sd)) {
      outlier.up <-
        which(tower_eo_sense.data$NEE[c(((ww - 1) * filter_window[w] + 1):
                                          (ww * filter_window[w]))] > 
                window_mean + filter_criteria[w] * window_sd)
      outlier.lo <-
        which(tower_eo_sense.data$NEE[c(((ww - 1) * filter_window[w] + 1):
                                          (ww * filter_window[w]))] < 
                window_mean - filter_criteria[w] * window_sd)
      
      tower_eo_sense.data$NEE[c(((ww - 1) * filter_window[w] + 1):
                                  (ww * filter_window[w]))][c(outlier.lo,
                                                              outlier.up)] <- NA
    }
  }
}

## visualize cleaned NEE for combination of treatments
col.code <- list(col.name = levels(as.factor(tower_eo_sense.data$treatment)),
                 col = c("firebrick4", "firebrick1", "grey", "deepskyblue4", "deepskyblue"))
png(
    paste0(
      out.path,
      Sys.Date(),
      "_original_NEE_bygroups.png"
    ),
    width = 6.5,
    height = 3.5,
    units = "in",
    pointsize = 10,
    res = 400
  )
par(mar = c(4, 4.5, 0.5, 0.5))
plot(tower_eo_sense.data$TIMESTAMP,
     tower_eo_sense.data$NEE,
     pch = 20,
     cex = 0.7,
     col = col.code$col[as.numeric(as.factor(tower_eo_sense.data$treatment))],
     las = 1,
     ylab = expression(CO[2]~flux~'('*mu*mol~m^{-2}~s^{-1}*')'),
     xlab = "")
mtext(side = 1,
      "TIMESTAMP",
      outer = F,
      line = 2.5)
points(tower_eo_sense.data$TIMESTAMP,
       tower_eo_sense.data$Flux,
       pch = 1,
       cex = 0.6,
       col = "gold")
abline(v = as.POSIXct("2020-10-16"),
       lty = 4)
legend("topleft",
       fill = c(col.code$col, "gold"),
       border = NA,
       legend = c(col.code$col.name, "chamber flux"),
       ncol = 2,
       cex = 0.7,
       bty = "n")
dev.off()

```

# Running bootstraps of GAM models
1. Split the data into separate subgroups for combination of treatment/control 
   sides, pre/post compost, day/nighttime, focusing on Nov-May data for now.
2. Re-sample each subgroup data with repeat
3. Train a GAM model for NEE for each subgroup
4. Predict NEE for each subgroup + complete record 
5. Repeat 2-4 for n times
6. Store all prediction for n iteration, used for extract summary

```{r}
## fill remaining gaps in predictors, by linear interpolation
tower_eo_sense.data$Rg <- na.approx(tower_eo_sense.data$Rg, na.rm = FALSE)
tower_eo_sense.data$VWC <- na.approx(tower_eo_sense.data$VWC, na.rm = FALSE)
tower_eo_sense.data$Tsoil_15cm <- na.approx(tower_eo_sense.data$Tsoil_15cm, na.rm = FALSE)

tower_eo_sense.sub <- subset(tower_eo_sense.data,
                             select = c(NEE, Rg, Tair, VWC, VPD, Tsoil_15cm,
                                        treatment, time.id, sin_Doy_water,
                                        cos_Doy_water, Month, HalfMonth))
tower_eo_sense.sub <- na.omit(tower_eo_sense.sub)

## Convert time windows into factor, in case used as a categorical predictor in GAMs
tower_eo_sense.data$cat_time <- as.factor(as.character(tower_eo_sense.data$Month))
tower_eo_sense.sub$cat_time <- as.factor(as.character(tower_eo_sense.sub$Month))

## Number of iteration for bootstrapping
n <- 500 

### split full data set into treatment/control & pre/post compost,
##   focus on growing season for now (Nov-May)
##   Store everything inside a list for code tidiness
grw.season <- c(11, 12, 1, 2, 3, 4)
day_data <-
  list(
    day_control_pre_data = tower_eo_sense.sub[
      tower_eo_sense.sub$treatment == "control_pre_compost" &
        tower_eo_sense.sub$Rg > 10 & 
        tower_eo_sense.sub$Month %in% grw.season, ],
    day_control_post_data = tower_eo_sense.sub[
      tower_eo_sense.sub$treatment == "control_post_compost" &
        tower_eo_sense.sub$Rg > 10 & 
        tower_eo_sense.sub$Month %in% grw.season, ],
    day_treatment_pre_data = tower_eo_sense.sub[
      tower_eo_sense.sub$treatment == "treatment_pre_compost" &
        tower_eo_sense.sub$Rg > 10 & 
        tower_eo_sense.sub$Month %in% grw.season, ],
    day_treatment_post_data = tower_eo_sense.sub[
      tower_eo_sense.sub$treatment == "treatment_post_compost" &  
        tower_eo_sense.sub$Rg > 10 & 
        tower_eo_sense.sub$Month %in% grw.season, ]
  )
night_data <-
  list(
    night_control_pre_data = tower_eo_sense.sub[
      tower_eo_sense.sub$treatment == "control_pre_compost" &
        tower_eo_sense.sub$Rg < 10 & 
        tower_eo_sense.sub$Month %in% grw.season, ],
    night_control_post_data = tower_eo_sense.sub[
      tower_eo_sense.sub$treatment == "control_post_compost" &
        tower_eo_sense.sub$Rg < 10 & 
        tower_eo_sense.sub$Month %in% grw.season, ],
    night_treatment_pre_data = tower_eo_sense.sub[
      tower_eo_sense.sub$treatment == "treatment_pre_compost" &
        tower_eo_sense.sub$Rg < 10 & 
        tower_eo_sense.sub$Month %in% grw.season, ],
    night_treatment_post_data = tower_eo_sense.sub[
      tower_eo_sense.sub$treatment == "treatment_post_compost" &
        tower_eo_sense.sub$Rg < 10 & 
        tower_eo_sense.sub$Month %in% grw.season, ]
  )
## all data, split into 1st & 2nd years (pre/post compost)
all_data <-
  list(
    all_pre_data = tower_eo_sense.data[
      tower_eo_sense.data$time.id < 2020 + 304 / 366 &
        tower_eo_sense.data$Month %in% grw.season, ],
    all_post_data = tower_eo_sense.data[
      tower_eo_sense.data$time.id > 2020 + 304 / 366 &
        tower_eo_sense.data$Month %in% grw.season, ]
  )

## temporary holder for prediction, subgroup-separated
day_predit <- list(
  day_control_pre = data.frame(NULL),
  day_control_post = data.frame(NULL),
  day_treatment_pre = data.frame(NULL),
  day_treatment_post = data.frame(NULL)
)
night_predit <- list(
  night_control_pre = data.frame(NULL),
  night_control_post = data.frame(NULL),
  night_treatment_pre = data.frame(NULL),
  night_treatment_post = data.frame(NULL)
)
# temporary holder for prediction, all time stamps
day_predit_all <- list(
  day_control_pre = data.frame(NULL),
  day_control_post = data.frame(NULL),
  day_treatment_pre = data.frame(NULL),
  day_treatment_post = data.frame(NULL)
)
night_predit_all <- list(
  night_control_pre = data.frame(NULL),
  night_control_post = data.frame(NULL),
  night_treatment_pre = data.frame(NULL),
  night_treatment_post = data.frame(NULL)
)

## temporary holder for re-sampling data
day_sample <- list(NULL)
night_sample <- list(NULL)

# create progress bar
pb <- txtProgressBar(min = 0,
                     max = max(n),
                     style = 3)
for (x in 1:n)
{
  
  ##############################################################################
  #### the following part deal with re-sampling (bootstrapping)
  #     First iteration, using the original data
  if (x == 1) {
    for (i in 1:4) {
      day_sample[[i]] <- day_data[[i]]
      night_sample[[i]] <- night_data[[i]]
    }
    
  } else{
    ## re-sample data for n-1 times, with the same sample size, but with repeats
    #   To balance samples, do re-sampling separately for each windows (cat_time),
    #   to ensure each window has been sampled
    for (i in 1:4) {
      mon.ls1 <- as.vector(na.omit(unique(day_data[[i]]$cat_time)))
      day_sample[[i]] <- 
        slice_sample(day_data[[i]][day_data[[i]]$cat_time == mon.ls1[1], ],
                     n = nrow(day_data[[i]][day_data[[i]]$cat_time == mon.ls1[1], ]),
                     replace = T)

      for(m in 2:length(mon.ls1)){
      day_sample[[i]] <- rbind.data.frame(
        day_sample[[i]],
        slice_sample(day_data[[i]][day_data[[i]]$cat_time == mon.ls1[m], ],
                     n = nrow(day_data[[i]][day_data[[i]]$cat_time == mon.ls1[m], ]),
                     replace = T)
        )  
      }

      mon.ls2 <- as.vector(na.omit(unique(night_data[[i]]$cat_time)))
      night_sample[[i]] <- 
        slice_sample(night_data[[i]][night_data[[i]]$cat_time == mon.ls2[1], ],
                     n = nrow(night_data[[i]][night_data[[i]]$cat_time == mon.ls2[1], ]),
                     replace = T)

      for(m in 2:length(mon.ls2)){
      night_sample[[i]] <- rbind.data.frame(
        night_sample[[i]],
        slice_sample(night_data[[i]][night_data[[i]]$cat_time == mon.ls2[m], ],
                     n = nrow(night_data[[i]][night_data[[i]]$cat_time == mon.ls2[m], ]),
                     replace = T)
        )  
      }
    }
  }

  ##############################################################################
  #### The following train GAM model
  ## Use similar list structure for storing GAM models
  night_gam <- list(NULL)
  day_gam <- list(NULL)
  
  for (i in 1:4) {
    #nighttime gam
    night_gam[[i]] <-
      gam(
        NEE ~ s(sin_Doy_water, k = 30) + s(cos_Doy_water, k = 30) + 
          s(Tsoil_15cm, k = 30) + s(Tair, k = 30) + s(VWC, k = 30) + 
          s(Tair, VWC, k = 30) + s(Tsoil_15cm, VWC, k = 30),
        data = night_sample[[i]],
        method = "REML",
        na.action = na.omit
      )
    
    # daytime gam
    day_gam[[i]] <-
      gam(
        NEE ~ s(sin_Doy_water, k = 30) + s(cos_Doy_water, k = 30) + 
          s(Rg, k = 30) + s(Tair, k = 30) + s(VWC, k = 30) + s(VPD, k = 30) + 
          s(Rg, VWC, k = 30) + s(Rg, VPD, k = 30),
        data = day_sample[[i]],
        method = "REML",
        na.action = na.omit
      )
    
    ## save the gam model summary, for the first iteration (original dataset) 
    if(x == 1){
      sink(paste0(out.path, Sys.Date(), "_", names(night_data)[i], "_gam.txt"))
      print(summary(night_gam[[i]]))
      sink()  
      
      sink(paste0(out.path, Sys.Date(), "_", names(day_data)[i], "_gam.txt"))
      print(summary(day_gam[[i]]))
      sink()  
      
    }
  }

  ##############################################################################
  #### The following use GAM to predict
  if (x == 1) {
    for (i in 1:4) {
      ## predict NEE for each sub-group
      night_predit[[i]] <- data.frame(
        predict(
          night_gam[[i]],
          night_data[[i]],
          type = "link",
          se.fit = FALSE,
          terms = NULL,
          exclude = NULL,
          block.size = NULL,
          newdata.guaranteed = FALSE,
          na.action = na.pass,
          unconditional = FALSE,
          iterms.type = NULL
        )
      )
      
      day_predit[[i]] <- data.frame(
        predict(
          day_gam[[i]],
          day_data[[i]],
          type = "link",
          se.fit = FALSE,
          terms = NULL,
          exclude = NULL,
          block.size = NULL,
          newdata.guaranteed = FALSE,
          na.action = na.pass,
          unconditional = FALSE,
          iterms.type = NULL
        )
      )
      
      ## predict NEE for all-record
      night_predit_all[[i]] <- data.frame(
        predict(
          night_gam[[i]],
          all_data[[ifelse(i %in% c(1, 3), 1, 2)]],
          type = "link",
          se.fit = FALSE,
          terms = NULL,
          exclude = NULL,
          block.size = NULL,
          newdata.guaranteed = FALSE,
          na.action = na.pass,
          unconditional = FALSE,
          iterms.type = NULL
        )
      )
      
      day_predit_all[[i]] <- data.frame(
        predict(
          day_gam[[i]],
          all_data[[ifelse(i %in% c(1, 3), 1, 2)]],
          type = "link",
          se.fit = FALSE,
          terms = NULL,
          exclude = NULL,
          block.size = NULL,
          newdata.guaranteed = FALSE,
          na.action = na.pass,
          unconditional = FALSE,
          iterms.type = NULL
        )
      )
    }
    
  } else{
    for (i in 1:4) {
      ## predict NEE for each sub-group
      night_predit[[i]] <- cbind.data.frame(
        night_predit[[i]],
        predict(
          night_gam[[i]],
          night_data[[i]],
          type = "link",
          se.fit = FALSE,
          terms = NULL,
          exclude = NULL,
          block.size = NULL,
          newdata.guaranteed = FALSE,
          na.action = na.pass,
          unconditional = FALSE,
          iterms.type = NULL
        )
      )
      
      day_predit[[i]] <- cbind.data.frame(
        day_predit[[i]],
        predict(
          day_gam[[i]],
          day_data[[i]],
          type = "link",
          se.fit = FALSE,
          terms = NULL,
          exclude = NULL,
          block.size = NULL,
          newdata.guaranteed = FALSE,
          na.action = na.pass,
          unconditional = FALSE,
          iterms.type = NULL
        )
      )
      
      ## predict NEE for all-record
      night_predit_all[[i]] <- cbind.data.frame(
        night_predit_all[[i]],
        predict(
          night_gam[[i]],
          all_data[[ifelse(i %in% c(1, 3), 1, 2)]],
          type = "link",
          se.fit = FALSE,
          terms = NULL,
          exclude = NULL,
          block.size = NULL,
          newdata.guaranteed = FALSE,
          na.action = na.pass,
          unconditional = FALSE,
          iterms.type = NULL
        )
      )
      
      day_predit_all[[i]] <- cbind.data.frame(
        day_predit_all[[i]],
        predict(
          day_gam[[i]],
          all_data[[ifelse(i %in% c(1, 3), 1, 2)]],
          type = "link",
          se.fit = FALSE,
          terms = NULL,
          exclude = NULL,
          block.size = NULL,
          newdata.guaranteed = FALSE,
          na.action = na.pass,
          unconditional = FALSE,
          iterms.type = NULL
        )
      )
    }
  }
 
  # update progress bar
  Sys.sleep(0.1)
  setTxtProgressBar(pb, x)
}
```

# Obtain model summary 
Use subgroup prediction to evaluate the model performance. Make prediction plot,
generate summary tables for model performance

```{r }
## Obtain mean, sd & 95% CI of prediction for each subgroup, append to the 
#   original split subgroups
for(i in 1:4) {
  night_data[[i]] <- cbind.data.frame(
    night_data[[i]],
    data.frame(
      NEE_predict_mean = rowMeans(night_predit[[i]], na.rm = TRUE),
      NEE_predict_sd = apply(night_predit[[i]], 1, sd, na.rm = TRUE),
      NEE_predict_q975 = apply(night_predit[[i]],
                               1,
                               quantile,
                               probs = 0.975,
                               na.rm = TRUE),
      NEE_predict_q025 = apply(night_predit[[i]],
                               1,
                               quantile,
                               probs = 0.025,
                               na.rm = TRUE)
    )
  )
  
  day_data[[i]] <- cbind.data.frame(
    day_data[[i]],
    data.frame(
      NEE_predict_mean = rowMeans(day_predit[[i]], na.rm = TRUE),
      NEE_predict_sd = apply(day_predit[[i]], 1, sd, na.rm = TRUE),
      NEE_predict_q975 = apply(day_predit[[i]],
                               1,
                               quantile, 
                               probs = 0.975, 
                               na.rm = TRUE),
      NEE_predict_q025 = apply(day_predit[[i]],
                               1,
                               quantile, 
                               probs = 0.025, 
                               na.rm = TRUE)
    )
  )
}

### Make prediction plot, generate summary for model performance
stat_subgroup <- data.frame(
  suggroup = rep(c("control_pre_compost", "control_post_compost",
                   "treatment_pre_compost", "treatment_post_compost"),
                 times = 2),
  daynight = rep(c("day", "night"), 
                 each = 4),
  samples = NA,
  rsquare = NA,
  slope = NA,
  intercept = NA,
  rmse = NA,
  mae = NA
)

###############################################################################
#### Following chunk compiles model summary tables & generate figures
for(i in 1:4) {
  lm1 <- summary(lm(NEE ~ NEE_predict_mean,
            data = day_data[[i]],
            na.action = na.omit))
  lm2 <- summary(lm(NEE ~ NEE_predict_mean,
            data = night_data[[i]],
            na.action = na.omit))
  
  stat_subgroup$samples[i] <- lm1$df[2] + 2
  stat_subgroup$samples[i + 4] <- lm2$df[2] + 2
  stat_subgroup$rsquare[i] <- lm1$r.squared
  stat_subgroup$rsquare[i + 4] <- lm2$r.squared
  stat_subgroup$slope[i] <- lm1$coefficients[2, 1]
  stat_subgroup$slope[i + 4] <- lm2$coefficients[2, 1]
  stat_subgroup$intercept[i] <- lm1$coefficients[1, 1]
  stat_subgroup$intercept[i + 4] <- lm2$coefficients[1, 1]
  stat_subgroup$rmse[i] <- sqrt(mean(lm1$residuals ^ 2))
  stat_subgroup$rmse[i + 4] <- sqrt(mean(lm2$residuals ^ 2))
  stat_subgroup$mae[i] <- mean(abs(lm1$residuals))
  stat_subgroup$mae[i + 4] <- mean(abs(lm2$residuals))
  
  #### generate plots
  png(
    paste0(
      out.path,
      Sys.Date(),
      "_",
      stat_subgroup$suggroup[i],
      "_",
      stat_subgroup$daynight[i],
      "_GAMS_model.png"
    ),
    width = 4.5,
    height = 4.5,
    units = "in",
    pointsize = 10,
    res = 400
  )
  par(mar = c(4.5, 4.5, 1.5, 0.5))
  plot(NEE ~ NEE_predict_mean,
       data = day_data[[i]],
       las = 1,
       ylab = expression(Observed~NEE~'('*mu*mole~m^{-2}~s^{-1}*')'),
       xlab = expression(Modeled~NEE~'('*mu*mole~m^{-2}~s^{-1}*')'),
       pch = 20, 
       col = rgb(0, 0, 0, 0.2),
       xlim = range(unlist(day_data[[i]][, c("NEE", "NEE_predict_mean")]), na.rm = T),
       ylim = range(unlist(day_data[[i]][, c("NEE", "NEE_predict_mean")]), na.rm = T))
  abline(a = stat_subgroup$intercept[i],
         b = stat_subgroup$slope[i],
         col = "red")
  mtext(side = 3,
        paste("Slope:", round(stat_subgroup$slope[i], digits = 2),
              "Intercpt:", round(stat_subgroup$intercept[i], digits = 2),
              "R2:", round(stat_subgroup$rsquare[i], digits = 2)),
        col = "red")
  dev.off()
  
  png(
    paste0(
      out.path,
      Sys.Date(),
      "_",
      stat_subgroup$suggroup[i + 4],
      "_",
      stat_subgroup$daynight[i + 4],
      "_GAMS_model.png"
    ),
    width = 4.5,
    height = 4.5,
    units = "in",
    pointsize = 10,
    res = 400
  )
  par(mar = c(4.5, 4.5, 1.5, 0.5))
  plot(NEE ~ NEE_predict_mean,
       data = night_data[[i]],
       las = 1,
       ylab = expression(Observed~NEE~'('*mu*mole~m^{-2}~s^{-1}*')'),
       xlab = expression(Modeled~NEE~'('*mu*mole~m^{-2}~s^{-1}*')'),
       pch = 20, 
       col = rgb(0, 0, 0, 0.2),
       xlim = range(unlist(night_data[[i]][, c("NEE", "NEE_predict_mean")]), na.rm = T),
       ylim = range(unlist(night_data[[i]][, c("NEE", "NEE_predict_mean")]), na.rm = T))
  abline(a = stat_subgroup$intercept[i + 4],
         b = stat_subgroup$slope[i + 4],
         col = "red")
  mtext(side = 3,
        paste("Slope:", round(stat_subgroup$slope[i + 4], digits = 2),
              "Intercpt:", round(stat_subgroup$intercept[i + 4], digits = 2),
              "R2:", round(stat_subgroup$rsquare[i + 4], digits = 2)),
        col = "red")
  dev.off()
}

write.csv(stat_subgroup,
          paste0(out.path, Sys.Date(), "_gams_model_statistics.csv"),
          row.names = F)

```

# Obtain modeled prediction for all timestamps
Obtain modeled NEE for each groups, merge back to the original & full-timestamp
data. NEE_predict columns contains GAMs predicted NEE (merged from day- & night-
based models). RECO_predict columns contains GAMs predicted NEE using only night-
based models. 

```{r }
## Obtain mean, sd & 95% CI of prediction for each subgroup, append to the 
#   original complete record
all_predict <- list(
  control_pre = data.frame(NULL),
  control_post = data.frame(NULL),
  treatment_pre = data.frame(NULL),
  treatment_post = data.frame(NULL)
)

#### merge the prediction matrix from day/nighttime
for(i in 1:4) {
  all_predict[[i]] <- night_predit_all[[i]]
  all_predict[[i]][!is.na(all_data[[ifelse(i %in% c(1, 3), 1, 2)]]$Rg) &
                     all_data[[ifelse(i %in% c(1, 3), 1, 2)]]$Rg > 10,] <-
    day_predit_all[[i]][!is.na(all_data[[ifelse(i %in% c(1, 3), 1, 2)]]$Rg) &
                          all_data[[ifelse(i %in% c(1, 3), 1, 2)]]$Rg > 10,]
  
}

## Obtain summary for predicted NEE & RECO, merge back to original data
for(i in 1:2) {
  all_data[[i]] <- cbind.data.frame(
    all_data[[i]],
    data.frame(
      NEE_predict_control_mean = rowMeans(all_predict[[i]], na.rm = TRUE),
      NEE_predict_control_sd = apply(all_predict[[i]], 1, sd, na.rm = TRUE),
      NEE_predict_control_q975 = apply(
        all_predict[[i]],
        1,
        quantile,
        probs = 0.975,
        na.rm = TRUE
      ),
      NEE_predict_control_q025 = apply(
        all_predict[[i]],
        1,
        quantile,
        probs = 0.025,
        na.rm = TRUE
      ),
      NEE_predict_treatment_mean = rowMeans(all_predict[[i + 2]], na.rm = TRUE),
      NEE_predict_treatment_sd = apply(all_predict[[i + 2]], 1, sd, na.rm = TRUE),
      NEE_predict_treatment_q975 = apply(
        all_predict[[i + 2]],
        1,
        quantile,
        probs = 0.975,
        na.rm = TRUE
      ),
      NEE_predict_treatment_q025 = apply(
        all_predict[[i + 2]],
        1,
        quantile,
        probs = 0.025,
        na.rm = TRUE
      ),
      RECO_predict_control_mean = rowMeans(night_predit_all[[i]], na.rm = TRUE),
      RECO_predict_control_sd = apply(night_predit_all[[i]], 1, sd, na.rm = TRUE),
      RECO_predict_control_q975 = apply(
        night_predit_all[[i]],
        1,
        quantile,
        probs = 0.975,
        na.rm = TRUE
      ),
      RECO_predict_control_q025 = apply(
        night_predit_all[[i]],
        1,
        quantile,
        probs = 0.025,
        na.rm = TRUE
      ),
      RECO_predict_treatment_mean = rowMeans(night_predit_all[[i + 2]], na.rm = TRUE),
      RECO_predict_treatment_sd = apply(night_predit_all[[i + 2]], 1, sd, na.rm = TRUE),
      RECO_predict_treatment_q975 = apply(
        night_predit_all[[i + 2]],
        1,
        quantile,
        probs = 0.975,
        na.rm = TRUE
      ),
      RECO_predict_treatment_q025 = apply(
        night_predit_all[[i + 2]],
        1,
        quantile,
        probs = 0.025,
        na.rm = TRUE
      )
    )
  )
}

col.code2 <- list(col.name = c("control", "treatment"),
                 col = c("firebrick1", "deepskyblue"))

##### Figure for modeled NEE
png(
    paste0(
      out.path,
      Sys.Date(),
      "_modeled_NEE_bygroups.png"
    ),
    width = 6.5,
    height = 3.5,
    units = "in",
    pointsize = 10,
    res = 400
  )
par(mar = c(4, 0.2, 0.5, 0.2), oma = c(0, 4, 0, 0.5), mfrow = c(1, 2))
plot(all_data[[1]]$TIMESTAMP,
     all_data[[1]]$NEE_predict_control_mean,
     pch = 20,
     cex = 0.7,
     col = col.code2$col[1],
     las = 1,
     ylab = "",
     xlab = "",
     ylim = c(-20, 20))
mtext(side = 1,
      "2020-2021",
      outer = F,
      line = 2.5)
mtext(side = 2,
      expression(CO[2]~flux~'('*mu*mol~m^{-2}~s^{-1}*')'),
      outer = T,
      line = 2.5)
points(all_data[[1]]$TIMESTAMP,
       all_data[[1]]$NEE_predict_treatment_mean,
       pch = 20,
       cex = 0.7,
       col = col.code2$col[2])
legend("topleft",
       fill = col.code2$col,
       border = NA,
       legend = col.code2$col.name,
       ncol = 2,
       cex = 0.7,
       bty = "n")
plot(all_data[[2]]$TIMESTAMP,
     all_data[[2]]$NEE_predict_control_mean,
     pch = 20,
     cex = 0.7,
     col = col.code2$col[1],
     las = 1,
     ylab = "",
     xlab = "",
     yaxt = "n",
     ylim = c(-20, 20))
mtext(side = 1,
      "2020-2021",
      outer = F,
      line = 2.5)
points(all_data[[2]]$TIMESTAMP,
       all_data[[2]]$NEE_predict_treatment_mean,
       pch = 20,
       cex = 0.7,
       col = col.code2$col[2])
dev.off()

## save output
saveRDS(all_predict,
        paste0(out.path, Sys.Date(), "_all_predict_matrix.rda"))


```

# Merge modeled prediction & original data for all timestamps (i.e., gap-filled)
Obtain modeled NEE for each groups, merge back to the original & full-timestamp
data. NEE_filled columns contains both original data & GAMs predicted NEE. 

#createReco filled columns?

```{r}
## merge prediction with original NEE, separated by control/treatment sides & 
#   models

all_filled <- list(
  control_pre = data.frame(NULL),
  control_post = data.frame(NULL),
  treatment_pre = data.frame(NULL),
  treatment_post = data.frame(NULL)
)

#### merge the prediction matrix w/ original observed data (i.e., gap-filled)
treatment.ls <- c("control_pre_compost", "control_post_compost",
                  "treatment_pre_compost", "treatment_post_compost")
for(i in 1:4) {
  all_filled[[i]] <- all_predict[[i]]
  all_filled[[i]][!is.na(all_data[[ifelse(i %in% c(1, 3), 1, 2)]]$NEE) &
                    all_data[[ifelse(i %in% c(1, 3), 1, 2)]]$treatment == treatment.ls[i], ] <-
    all_data[[ifelse(i %in% c(1, 3), 1, 2)]]$NEE[
      !is.na(all_data[[ifelse(i %in% c(1, 3), 1, 2)]]$NEE) &
        all_data[[ifelse(i %in% c(1, 3), 1, 2)]]$treatment == treatment.ls[i]]
  
}


## Obtain summary for filled NEE & RECO, merge back to original data
#Do we need to do the same for RECO?
for(i in 1:2) {
  all_data[[i]] <- cbind.data.frame(
    all_data[[i]],
    data.frame(
      NEE_filled_control_mean = rowMeans(all_filled[[i]], na.rm = TRUE),
      NEE_filled_control_sd = apply(all_filled[[i]], 1, sd, na.rm = TRUE),
      NEE_filled_control_q975 = apply(
        all_filled[[i]],
        1,
        quantile,
        probs = 0.975,
        na.rm = TRUE
      ),
      NEE_filled_control_q025 = apply(
        all_filled[[i]],
        1,
        quantile,
        probs = 0.025,
        na.rm = TRUE
      ),
      NEE_filled_treatment_mean = rowMeans(all_filled[[i + 2]], na.rm = TRUE),
      NEE_filled_treatment_sd = apply(all_filled[[i + 2]], 1, sd, na.rm = TRUE),
      NEE_filled_treatment_q975 = apply(
        all_filled[[i + 2]],
        1,
        quantile,
        probs = 0.975,
        na.rm = TRUE
      ),
      NEE_filled_treatment_q025 = apply(
        all_filled[[i + 2]],
        1,
        quantile,
        probs = 0.025,
        na.rm = TRUE
      )
    )
  )
}


col.code3 <- list(col.name = c("control (modeled)", "treatment (modeled)",
                               "control (observed)", "treatment (observed)"),
                  col = c("firebrick1", "deepskyblue", "firebrick4", "deepskyblue4"))

##### Figure for filled NEE
png(
    paste0(
      out.path,
      Sys.Date(),
      "_filled_NEE_bygroups.png"
    ),
    width = 6.5,
    height = 3.5,
    units = "in",
    pointsize = 10,
    res = 400
  )
par(
  mar = c(4, 0.2, 0.5, 0.2),
  oma = c(0, 4, 0, 0.5),
  mfrow = c(1, 2)
)
plot(
  all_data[[1]]$TIMESTAMP,
  all_data[[1]]$NEE_filled_control_mean,
  pch = 20,
  cex = 0.7,
  col = col.code3$col[1],
  las = 1,
  ylab = "",
  xlab = "",
  ylim = c(-20, 20)
)
points(
  all_data[[1]]$TIMESTAMP,
  all_data[[1]]$NEE_filled_treatment_mean,
  pch = 20,
  cex = 0.7,
  col = col.code3$col[2]
)
points(
  all_data[[1]]$TIMESTAMP[all_data[[1]]$treatment == "control_pre_compost"],
  all_data[[1]]$NEE[all_data[[1]]$treatment == "control_pre_compost"],
  pch = 20,
  cex = 0.7,
  col = col.code3$col[3]
)
points(
  all_data[[1]]$TIMESTAMP[all_data[[1]]$treatment == "treatment_pre_compost"],
  all_data[[1]]$NEE[all_data[[1]]$treatment == "treatment_pre_compost"],
  pch = 20,
  cex = 0.7,
  col = col.code3$col[4]
)
mtext(side = 1,
      "2019-2020",
      outer = F,
      line = 2.5)
mtext(
  side = 2,
  expression(CO[2] ~ flux ~ '(' * mu * mol ~ m ^ {
    -2
  } ~ s ^ {
    -1
  } * ')'),
  outer = T,
  line = 2.5
)

legend(
  "topleft",
  fill = col.code3$col,
  border = NA,
  legend = col.code3$col.name,
  ncol = 2,
  cex = 0.7,
  bty = "n"
)
plot(
  all_data[[2]]$TIMESTAMP,
  all_data[[2]]$NEE_filled_control_mean,
  pch = 20,
  cex = 0.7,
  col = col.code3$col[1],
  las = 1,
  ylab = "",
  xlab = "",
  yaxt = "n",
  ylim = c(-20, 20)
)
mtext(side = 1,
      "2020-2021",
      outer = F,
      line = 2.5)
points(
  all_data[[2]]$TIMESTAMP,
  all_data[[2]]$NEE_filled_treatment_mean,
  pch = 20,
  cex = 0.7,
  col = col.code3$col[2]
)
points(
  all_data[[2]]$TIMESTAMP[all_data[[2]]$treatment == "control_post_compost"],
  all_data[[2]]$NEE[all_data[[2]]$treatment == "control_post_compost"],
  pch = 20,
  cex = 0.7,
  col = col.code3$col[3]
)
points(
  all_data[[2]]$TIMESTAMP[all_data[[2]]$treatment == "treatment_post_compost"],
  all_data[[2]]$NEE[all_data[[2]]$treatment == "treatment_post_compost"],
  pch = 20,
  cex = 0.7,
  col = col.code3$col[4]
)
dev.off()

## save output
saveRDS(all_filled,
        paste0(out.path, Sys.Date(), "_all_filled_matrix.rda"))


```

# Generate cumulative NEE curves +/- uncertainties
The uncertainty level is based on GAM bootstrapping. For period with valid original 
data, it's treated as no uncertainty for now. 

#do for reco as well?


```{r}
## Generate cumulative curves (time series) based on gap-filled ones
all_filled_cum <- list(
  control_pre = data.frame(NULL),
  control_post = data.frame(NULL),
  treatment_pre = data.frame(NULL),
  treatment_post = data.frame(NULL)
)

#another list for reco and another list for GPP

## Calculate cumulative NEE sum, convert unit to g C m-2
#Then calculate cumulative sums for GPP and Reco
for(i in 1:4) {
  all_filled_cum[[i]] <- apply(all_filled[[i]], 2, cumsum) * 1800 / 1000000 * 12
}


## Obtain summary for filled cumulative NEE, merge back to original data
#Do something similiar for GPP and Reco
for(i in 1:2) {
  all_data[[i]] <- cbind.data.frame(
    all_data[[i]],
    data.frame(
      NEE_filled_cum_control_mean = rowMeans(all_filled_cum[[i]], na.rm = TRUE),
      NEE_filled_cum_control_sd = apply(all_filled_cum[[i]], 1, sd, na.rm = TRUE),
      NEE_filled_cum_control_q975 = apply(
        all_filled_cum[[i]],
        1,
        quantile,
        probs = 0.975,
        na.rm = TRUE
      ),
      NEE_filled_cum_control_q025 = apply(
        all_filled_cum[[i]],
        1,
        quantile,
        probs = 0.025,
        na.rm = TRUE
      ),
      NEE_filled_cum_treatment_mean = rowMeans(all_filled_cum[[i + 2]], na.rm = TRUE),
      NEE_filled_cum_treatment_sd = apply(all_filled_cum[[i + 2]], 1, sd, na.rm = TRUE),
      NEE_filled_cum_treatment_q975 = apply(
        all_filled_cum[[i + 2]],
        1,
        quantile,
        probs = 0.975,
        na.rm = TRUE
      ),
      NEE_filled_cum_treatment_q025 = apply(
        all_filled_cum[[i + 2]],
        1,
        quantile,
        probs = 0.025,
        na.rm = TRUE
      )
    )
  )
}

##### Figure for filled NEE
png(
    paste0(
      out.path,
      Sys.Date(),
      "_filled_cum_NEE_bygroups.png"
    ),
    width = 6.5,
    height = 3.5,
    units = "in",
    pointsize = 10,
    res = 400
  )
par(mar = c(4, 0.2, 0.5, 0.2), oma = c(0, 4, 0, 0.5), mfrow = c(1, 2))
plot(all_data[[1]]$TIMESTAMP,
     all_data[[1]]$NEE_filled_cum_control_mean,
     pch = 20,
     cex = 0.7,
     col = col.code2$col[1],
     las = 1,
     ylab = "",
     xlab = "",
     ylim = c(-200, 450))
mtext(side = 2,
      expression(Cumulative~CO[2]~flux~'('*g~C~m^{-2}*')'),
      outer = T,
      line = 2.5)
mtext(side = 1,
      "2019-2020",
      outer = F,
      line = 2.5)
points(all_data[[1]]$TIMESTAMP,
       all_data[[1]]$NEE_filled_cum_treatment_mean,
       pch = 20,
       cex = 0.7,
       col = col.code2$col[2])
lines(all_data[[1]]$TIMESTAMP,
      all_data[[1]]$NEE_filled_cum_control_q025,
      col = col.code2$col[1],
      lty = 2)
lines(all_data[[1]]$TIMESTAMP,
      all_data[[1]]$NEE_filled_cum_control_q975,
      col = col.code2$col[1],
      lty = 2)
lines(all_data[[1]]$TIMESTAMP,
      all_data[[1]]$NEE_filled_cum_treatment_q025,
      col = col.code2$col[2],
      lty = 2)
lines(all_data[[1]]$TIMESTAMP,
      all_data[[1]]$NEE_filled_cum_treatment_q975,
      col = col.code2$col[2],
      lty = 2)
legend("topleft",
       fill = col.code2$col,
       border = NA,
       legend = col.code2$col.name,
       ncol = 2,
       cex = 0.7,
       bty = "n")
plot(all_data[[2]]$TIMESTAMP,
     all_data[[2]]$NEE_filled_cum_control_mean,
     pch = 20,
     cex = 0.7,
     col = col.code2$col[1],
     las = 1,
     ylab = "",
     xlab = "",
     yaxt = "n",
     ylim = c(-200, 450))
mtext(side = 1,
      "2020-2021",
      outer = F,
      line = 2.5)
points(all_data[[2]]$TIMESTAMP,
       all_data[[2]]$NEE_filled_cum_treatment_mean,
       pch = 20,
       cex = 0.7,
       col = col.code2$col[2])
lines(all_data[[2]]$TIMESTAMP,
      all_data[[2]]$NEE_filled_cum_control_q025,
      col = col.code2$col[1],
      lty = 2)
lines(all_data[[2]]$TIMESTAMP,
      all_data[[2]]$NEE_filled_cum_control_q975,
      col = col.code2$col[1],
      lty = 2)
lines(all_data[[2]]$TIMESTAMP,
      all_data[[2]]$NEE_filled_cum_treatment_q025,
      col = col.code2$col[2],
      lty = 2)
lines(all_data[[2]]$TIMESTAMP,
      all_data[[2]]$NEE_filled_cum_treatment_q975,
      col = col.code2$col[2],
      lty = 2)
dev.off()

## save output
saveRDS(all_filled_cum,
        paste0(out.path, Sys.Date(), "_all_filled_cum_matrix.rda"))

## save output
saveRDS(all_data,
        paste0(out.path, Sys.Date(), "_all_data.rda"))


```

# Generate cumulative sum tables for different time periiods
Calendar months (Both Growing Seasons): Nov 1- April 30

Phenology (From field pictures still waiting on Patty to finish her phenocam analysis): 
Growing season 1: 12/5/2019 - 4/26/2020 (DOY 339 - 117)
Growing season 2: 1/12/2021- 4/26/2021 (compost side) (12 - 116)
The non-compost side did sart to not green up until 2/3.

Soil Moisture/Precip (Based on day before first 5% soil moisture to day after last 5% moisture)
-Of the two soil moistures this one seems to align the best with the phenology. 
Growing season 1: 11/25/2019- 4/29/2020 (329 - 120)
Growing season 2:  1/26/2021- 4/27/2021 (26 - 117)

Soil Moisture/Precip (Based on day before first 10% soil moisture to day after last 10% soil moisture):
Growing season 1: 11/25/2019- 4/21/2020 (329 - 112)
Growing season 2:  1/26/2021- 4/2/2021 (26 - 92)

```{r}
## define the starting & ending date of each period
period_loc <- list(
  start = c(
    0,
    0,
    which(all_data$all_pre_data$time.id == 2019 + 339 / 366),
    which(all_data$all_post_data$time.id == 2021 + 12 / 366),
    which(all_data$all_pre_data$time.id == 2019 + 329 / 366),
    which(all_data$all_post_data$time.id == 2021 + 26 / 366),
    which(all_data$all_pre_data$time.id == 2019 + 329 / 366),
    which(all_data$all_post_data$time.id == 2021 + 26 / 366)
  ),
  end = c(
    length(all_data$all_pre_data$NEE_filled_control_mean),
    length(all_data$all_post_data$NEE_filled_control_mean),
    which(all_data$all_pre_data$time.id == 2020 + 117 / 366),
    which(all_data$all_post_data$time.id == 2021 + 116 / 366),
    which(all_data$all_pre_data$time.id == 2020 + 120 / 366),
    which(all_data$all_post_data$time.id == 2021 + 117 / 366),
    which(all_data$all_pre_data$time.id == 2020 + 112 / 366),
    which(all_data$all_post_data$time.id == 2021 + 92 / 366)
  )
)

### locate corresponding sum NEE
sum_table <- data.frame(
  period = c(
    "Nov_Apr_year1",
    "Nov_Apr_year2",
    "phenology_year1",
    "phenology_year2",
    "vwc05_year1",
    "vwc05_year2",
    "vwc10_year1",
    "vwc10_year2"
  ),
  n_data = (period_loc$end - period_loc$start + 1),
  control_mean = NA,
  control_sd = NA,
  control_q975 = NA,
  control_q025 = NA,
  treatment_mean = NA,
  treatment_sd = NA,
  treatment_q975 = NA,
  treatment_q025 = NA
  )
  
all_data_col_locate <- c("NEE_filled_cum_control_mean",
                         "NEE_filled_cum_control_sd",
                         "NEE_filled_cum_control_q975",
                         "NEE_filled_cum_control_q025",
                         "NEE_filled_cum_treatment_mean",
                         "NEE_filled_cum_treatment_sd",
                         "NEE_filled_cum_treatment_q975",
                         "NEE_filled_cum_treatment_q025")

for(tt in 1:length(all_data_col_locate)){
  for(ttt in 1:nrow(sum_table)){
    if(ttt != 2 * ceiling(ttt/2)){
      ## odd row / year 1
      # locate end sum
      sum_table[ttt, tt + 2] <- all_data[[1]][period_loc$end[ttt], all_data_col_locate[tt]] 
      # subtract start sum
      if(period_loc$start[ttt] > 0)
        sum_table[ttt, tt + 2] <- sum_table[ttt, tt + 2] -
          all_data[[1]][period_loc$start[ttt], all_data_col_locate[tt]]
    }else{
      # even row / year 2
      # locate end sum
      sum_table[ttt, tt + 2] <- all_data[[2]][period_loc$end[ttt], all_data_col_locate[tt]] 
      # subtract start sum
      if(period_loc$start[ttt] > 0)
        sum_table[ttt, tt + 2] <- sum_table[ttt, tt + 2] -
          all_data[[2]][period_loc$start[ttt], all_data_col_locate[tt]]
    }
  }
}
write.csv(sum_table,
          paste0(out.path, Sys.Date(), "_filledNEE_cum_sum_bygroup.csv"),
          row.names = F)

```

# Generate daily time series for all predict and filled
The uncertainty level is based on GAM bootstrapping. For period with valid original 
data, it's treated as no uncertainty for now.

#still need to do for reco to?

```{r}
## Generate daily time series based on gap-filled & predict matrix
all_predict_daily <- all_filled_daily <- list(
  control_pre = data.frame(NULL),
  control_post = data.frame(NULL),
  treatment_pre = data.frame(NULL),
  treatment_post = data.frame(NULL)
)

## 
daily_mean <- function(x){
  idx <- as.factor(rep(c(1:ceiling(length(x) / 48)), each = 48))[c(1:length(x))]
  y = tapply(x, idx, mean, na.rm = T)
  return(y)
}
# Calculate daily NEE, convert unit to g C m-2 for all iterations
for(i in 1:4) {
  all_filled_daily[[i]] <-
    apply(all_filled[[i]], 2, daily_mean) * 1800 / 1000000 * 12 * 48
  all_predict_daily[[i]] <-
    apply(all_predict[[i]], 2, daily_mean) * 1800 / 1000000 * 12 * 48
}

daily_head <- function(x){
  idx <- rep(c(1:48), ceiling(length(x) / 48))[c(1:length(x))]
  y = x[which(idx == 1)]
  return(y)
} 
## prepare all data daily
all_data_daily <- list(
  all_pre_data = data.frame(
    TIMESTAMP = daily_head(all_data[[1]]$TIMESTAMP),
    Doy = daily_mean(all_data[[1]]$Doy),
    Doy_water = daily_mean(all_data[[1]]$Doy_water)
  ),
  all_post_data = data.frame(
    TIMESTAMP = daily_head(all_data[[2]]$TIMESTAMP),
    Doy = daily_mean(all_data[[2]]$Doy),
    Doy_water = daily_mean(all_data[[2]]$Doy_water)
  )
)
  
## Obtain summary for filled NEE & RECO, merge back to original data
for(i in 1:2) {
  all_data_daily[[i]] <- cbind.data.frame(
    all_data_daily[[i]],
    data.frame(
      NEE_predict_control_mean = rowMeans(all_predict_daily[[i]], na.rm = TRUE),
      NEE_predict_control_sd = apply(all_predict_daily[[i]], 1, sd, na.rm = TRUE),
      NEE_predict_control_q975 = apply(
        all_predict_daily[[i]],
        1,
        quantile,
        probs = 0.975,
        na.rm = TRUE
      ),
      NEE_predict_control_q025 = apply(
        all_predict_daily[[i]],
        1,
        quantile,
        probs = 0.025,
        na.rm = TRUE
      ),
      NEE_predict_treatment_mean = rowMeans(all_predict_daily[[i + 2]], na.rm = TRUE),
      NEE_predict_treatment_sd = apply(all_predict_daily[[i + 2]], 1, sd, na.rm = TRUE),
      NEE_predict_treatment_q975 = apply(
        all_predict_daily[[i + 2]],
        1,
        quantile,
        probs = 0.975,
        na.rm = TRUE
      ),
      NEE_predict_treatment_q025 = apply(
        all_predict_daily[[i + 2]],
        1,
        quantile,
        probs = 0.025,
        na.rm = TRUE
      ),
      NEE_filled_control_mean = rowMeans(all_filled_daily[[i]], na.rm = TRUE),
      NEE_filled_control_sd = apply(all_filled_daily[[i]], 1, sd, na.rm = TRUE),
      NEE_filled_control_q975 = apply(
        all_filled_daily[[i]],
        1,
        quantile,
        probs = 0.975,
        na.rm = TRUE
      ),
      NEE_filled_control_q025 = apply(
        all_filled_daily[[i]],
        1,
        quantile,
        probs = 0.025,
        na.rm = TRUE
      ),
      NEE_filled_treatment_mean = rowMeans(all_filled_daily[[i + 2]], na.rm = TRUE),
      NEE_filled_treatment_sd = apply(all_filled_daily[[i + 2]], 1, sd, na.rm = TRUE),
      NEE_filled_treatment_q975 = apply(
        all_filled_daily[[i + 2]],
        1,
        quantile,
        probs = 0.975,
        na.rm = TRUE
      ),
      NEE_filled_treatment_q025 = apply(
        all_filled_daily[[i + 2]],
        1,
        quantile,
        probs = 0.025,
        na.rm = TRUE
      )
    )
  )
}

col.code4 <- list(col.name = c("control", "treatment"),
                  col = c("firebrick4", "deepskyblue4"),
                  col2 = c(rgb(1, 0, 0, 0.3), rgb(0, 0, 1, 0.3)))

##### Figure for gap-filled daily NEE
png(
    paste0(
      out.path,
      Sys.Date(),
      "_filled_daily_NEE_bygroups.png"
    ),
    width = 6.5,
    height = 3.5,
    units = "in",
    pointsize = 10,
    res = 400
  )
par(mar = c(4, 0.2, 0.5, 0.2), oma = c(0, 4, 0, 0.5), mfrow = c(1, 2))
plot(0,
     0,
     las = 1,
     ylab = "",
     xlab = "",
     ylim = c(-10, 10),
     xlim = range(all_data_daily[[1]]$Doy_water),
     type = "n")
mtext(side = 1,
      "2019-2020",
      outer = F,
      line = 2.5)
mtext(side = 2,
      expression(CO[2]~flux~'('*g~C~m^{-2}~d^{-1}*')'),
      outer = T,
      line = 2.5)
polygon(c(all_data_daily[[1]]$Doy_water,
          rev(all_data_daily[[1]]$Doy_water)),
        c(all_data_daily[[1]]$NEE_filled_control_q975,
          rev(all_data_daily[[1]]$NEE_filled_control_q025)),
        col = col.code4$col2[1],
        border = NA)
polygon(c(all_data_daily[[1]]$Doy_water,
          rev(all_data_daily[[1]]$Doy_water)),
        c(all_data_daily[[1]]$NEE_filled_treatment_q975,
          rev(all_data_daily[[1]]$NEE_filled_treatment_q025)),
        col = col.code4$col2[2],
        border = NA)
points(all_data_daily[[1]]$Doy_water,
       all_data_daily[[1]]$NEE_filled_control_mean,
       pch = 20,
       cex = 0.7,
       col = col.code4$col[1])
points(all_data_daily[[1]]$Doy_water,
       all_data_daily[[1]]$NEE_filled_treatment_mean,
       pch = 20,
       cex = 0.7,
       col = col.code4$col[2])
legend("topleft",
       fill = col.code4$col,
       border = NA,
       legend = col.code2$col.name,
       ncol = 2,
       cex = 0.7,
       bty = "n")
plot(0,
     0,
     las = 1,
     ylab = "",
     xlab = "",
     yaxt = "n",
     ylim = c(-10, 10),
     xlim = range(all_data_daily[[2]]$Doy_water),
     type = "n")
mtext(side = 1,
      "2020-2021",
      outer = F,
      line = 2.5)
polygon(c(all_data_daily[[2]]$Doy_water,
          rev(all_data_daily[[2]]$Doy_water)),
        c(all_data_daily[[2]]$NEE_filled_control_q975,
          rev(all_data_daily[[2]]$NEE_filled_control_q025)),
        col = col.code4$col2[1],
        border = NA)
polygon(c(all_data_daily[[2]]$Doy_water,
          rev(all_data_daily[[2]]$Doy_water)),
        c(all_data_daily[[2]]$NEE_filled_treatment_q975,
          rev(all_data_daily[[2]]$NEE_filled_treatment_q025)),
        col = col.code4$col2[2],
        border = NA)
points(all_data_daily[[2]]$Doy_water,
       all_data_daily[[2]]$NEE_filled_control_mean,
       pch = 20,
       cex = 0.7,
       col = col.code4$col[1])
points(all_data_daily[[2]]$Doy_water,
       all_data_daily[[2]]$NEE_filled_treatment_mean,
       pch = 20,
       cex = 0.7,
       col = col.code4$col[2])
dev.off()

## save output
saveRDS(all_data_daily,
        paste0(out.path, Sys.Date(), "_all_data_daily.rda"))

```

